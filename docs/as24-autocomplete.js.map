{"version":3,"names":[],"mappings":"","sources":["src/as24-autocomplete.js"],"sourcesContent":["/**\n * @class DOMEvent\n * @property {HTMLElement} target\n * @property {number} which\n * @property {function} stopPropagation\n * @property {function} preventDefault\n */\n\n\n\n/**\n * @callback fetchItemsFn\n * @param {string} userInput\n * @return {Promise}\n */\n\n\n\n/**\n * Finds a closest element by class name\n * @param {string} className\n * @returns {function}\n */\nvar closestByClassName = function (className) { return function (elem) {\n        // Fix for IE.\n        if (elem.tagName === 'HTML') {\n            return null;\n        }\n        return elem.classList.contains(className)\n            ? elem\n            : closestByClassName(className)(elem.parentNode);\n    }; };\n\n\n\n/**\n * Checks whether elem has tag as a parent\n * @param {HTMLElement} tag\n * @returns {function}\n */\nvar closestByTag = function (tag) { return function (elem) { return elem === null\n            ? null\n            : (elem === tag)\n                ? tag\n                : closestByTag(tag)(elem.parentNode); }; };\n\n\n\n/**\n * Selects an element using the root element.\n * @param {string} selector Specifies the selector for lookup\n * @param {Element} root Specified within which element to perform the lookup\n * @return {Element}\n */\nvar $ = function (selector, root) { return root.querySelector(selector); };\n\n\n\n/**\n * Binds an event listener on the element\n * @param {string} event\n * @param {Function} cb\n * @param {Element|Window|Document} el\n * @param {boolean} capturing\n */\nvar on = function (event, cb, el, capturing) {\n        if ( capturing === void 0 ) capturing = false;\n\n        return el.addEventListener(event, cb, capturing);\n};\n\n\n\n/**\n * Appends a child element to a target element\n * @param {HTMLElement|DocumentFragment} target\n * @returns {function}\n */\nvar appendTo = function (target) { return function (child) {\n        target.appendChild(child);\n        return target;\n    }; };\n\n\n\n/**\n* Finds the currently selected suggestion item\n* @param {HTMLUListElement} list\n* @returns {HTMLLIElement}\n*/\nvar getSelectedSuggestionItem = function (list) { return $('.as24-autocomplete__list-item--selected', list); };\n\n\n\n/**\n*\n* @param {HTMLElement} list\n* @param {HTMLElement} selected\n*/\nvar followSelectedItem = function (list, selected) {\n    var listHeight = list.getBoundingClientRect().height;\n    var selectedTop = selected.offsetTop;\n    var selectedHeight = selected.offsetHeight;\n    list.scrollTop = -1 * (listHeight - (selectedTop + selectedHeight));\n};\n\n\n\n/**\n * Selected next/prev suggestion item\n * @param {number} dir\n * @param {HTMLUListElement} list\n * @return {boolean}\n */\nvar moveSelection = function (dir, list) {\n    var next = dir === 1 ? 'nextSibling' : 'previousSibling';\n    var currActiveItem = getSelectedSuggestionItem(list);\n    var nextActiveItem = currActiveItem === null\n        ? $('.as24-autocomplete__list-item', list)\n        : currActiveItem[next] !== null\n            ? currActiveItem[next]\n            : currActiveItem;\n    if (currActiveItem) {\n        currActiveItem.classList.remove('as24-autocomplete__list-item--selected');\n    }\n    nextActiveItem.classList.add('as24-autocomplete__list-item--selected');\n    followSelectedItem(list, nextActiveItem);\n    return false;\n};\n\n\n\n/**\n * Shows the suggestions list\n * @param {HTMLUListElement} list\n * @return {boolean}\n */\nvar showList = function (list) {\n    list.classList.add('as24-autocomplete__list--visible');\n    moveSelection(1, list);\n    return false;\n};\n\n\n\n/**\n * Hides the list and deactivates the root element\n * @param {HTMLUListElement} list\n * @param {Element} rootElement\n */\nvar hideList = function (list, rootElement) { return function () {\n    rootElement.classList.remove('as24-autocomplete--active');\n    list.classList.remove('as24-autocomplete__list--visible');\n    return false;\n}; };\n\n\n\n/**\n * Checks whether the list is visisible\n * @param {Element} list\n */\nvar isListVisible = function (list) { return list.classList.contains('as24-autocomplete__list--visible'); };\n\n\n\n/**\n * Remove error highlighting when there is something to suggest\n * @param {HTMLElement} rootElement\n * @return {*}\n */\nvar removeInputError = function (rootElement) {\n    var input = $('.as24-autocomplete__input', rootElement);\n    input.classList.remove('error');\n};\n\n\n\n/**\n * When user clicks cross icon, all the input must be removed\n * @param {HTMLInputElement} valueInput\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLElement} rootElement\n * @return {*}\n */\nvar cleanup = function (valueInput, userFacingInput, rootElement) {\n    valueInput.value = '';\n    userFacingInput.value = '';\n    rootElement.isDirty = false;\n    rootElement.classList.remove('as24-autocomplete--user-input');\n    removeInputError(rootElement);\n};\n\n\n\n/**\n * When user types something in we mark the component as dirty\n * @param {Element} rootElement\n * @return {*}\n */\nvar dirtifyInput = function (rootElement) {\n    rootElement.isDirty = true;\n    rootElement.classList.add('as24-autocomplete--user-input');\n};\n\n\n\n/**\n * Renders a li item for the suggestions list\n * @param {string} searchStr\n * @returns {function}\n */\nvar renderLI = function (searchStr) { return function (item) {\n        var li = document.createElement('li');\n        var escapedSearchStr = searchStr.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n        li.classList.add('as24-autocomplete__list-item');\n        li.dataset.key = item.key;\n        li.innerHTML = item.value.replace(new RegExp((\"(\" + escapedSearchStr + \")\"), 'ig'), '<strong>$1</strong>');\n        return li;\n    }; };\n\n/**\n * Highlight an error when there is nothing to suggest\n * @param {HTMLElement} rootElement\n * @return {*}\n */\nvar setInputError = function (rootElement) {\n    var input = $('.as24-autocomplete__input', rootElement);\n    input.classList.add('error');\n};\n\n\n\n/**\n * What to render when there is nothing to suggest\n * @param {String} emptyMessage\n * @param {HTMLElement} rootElement\n * @returns {HTMLLIElement}\n */\nvar renderEmptyListItem = function (emptyMessage, rootElement) {\n    setInputError(rootElement);\n    /**\n     * @type {HTMLLIElement}\n     */\n    var li = document.createElement('li');\n    li.dataset.unselectable = true;\n    ['as24-autocomplete__list-item', 'as24-autocomplete__list-item--empty'].forEach(li.classList.add.bind(li.classList));\n    li.dataset.key = '';\n    li.innerText = emptyMessage;\n    return li;\n};\n\n\n\n/**\n * Renders a collection of raw suggestions to the list\n * @param {string} emptyMessage\n * @param {HTMLUListElement} list\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLElement} rootElement\n * @returns {Function}\n */\nvar renderList = function (emptyMessage, list, userFacingInput, rootElement) { return function (suggestions) {\n        list.innerHTML = '';\n        var df = document.createDocumentFragment();\n\n        (suggestions.length\n            ? suggestions.map(renderLI(userFacingInput.value))\n            : [renderEmptyListItem(emptyMessage, rootElement)]\n        ).forEach(appendTo(df));\n\n        appendTo(list)(df);\n        showList(list);\n    }; };\n\n\n\n/**\n * Fetch data according to user input and renders the list\n * @param {DataSource} dataSource\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLUListElement} list\n * @param {String} emptyMessage\n * @param {Element} rootElement\n * @returns {function}\n */\nvar fetchList = function (dataSource, userFacingInput, list, emptyMessage, rootElement) { return function (e) {\n        e.stopPropagation();\n        rootElement.classList.add('as24-autocomplete--active');\n        removeInputError(rootElement);\n        dataSource.fetchItems(userFacingInput.value)\n            .then(renderList(emptyMessage, list, userFacingInput, rootElement));\n    }; };\n\n\n/**\n *\n * @param {string} eventName\n * @param {HTMLInputElement} el\n */\nvar triggerChangeEvent = function (eventName, el) {\n    var evt = document.createEvent('Event');\n    evt.initEvent(eventName, true, true);\n    el.dispatchEvent(evt);\n};\n\n\n/**\n * This is what happens after the user selected an item\n * @param {HTMLInputElement} valueInput\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLLIElement} li\n * @param {Element} rootElement\n * @param {HTMLUListElement} list\n */\nvar selectItem = function (valueInput, userFacingInput, li, rootElement, list) {\n    if (!li) {\n        li = getSelectedSuggestionItem(list);\n        if (li.classList.contains('as24-autocomplete__list-item--empty')) {\n            return;\n        }\n        hideList(list, rootElement)();\n    }\n\n    valueInput.value = li.dataset.key;\n    userFacingInput.value = li.innerText;\n    triggerChangeEvent('change', valueInput);\n    dirtifyInput(rootElement);\n};\n\n\n\n/**\n * When mouse goes over the suggestion item\n * @param {HTMLUListElement} list\n * @return {function} a function that accepts an event\n */\nvar onItemMouseOver = function (list) { return function (e) {\n        e.stopPropagation();\n        var preselected = $('.as24-autocomplete__list-item--preselected', list);\n        if (e.target.tagName === 'LI') {\n            if (preselected) {\n                preselected.classList.remove('as24-autocomplete__list-item--preselected');\n            }\n            e.target.classList.add('as24-autocomplete__list-item--preselected');\n        }\n    }; };\n\n\n\n/**\n * Handles key down event from the label input\n * @param {DataSource} dataSource\n * @param {HTMLInputElement} valueInput\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLUListElement} list\n * @param {string} emptyListMessage\n * @param {Element} rootElement\n * @return {function}\n */\nvar onKeyDown = function (dataSource, valueInput, userFacingInput, list, emptyListMessage, rootElement) { return function (e) {\n        if (e.target === userFacingInput) {\n            if ([38, 40, 27].indexOf(e.which) >= 0) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            if (e.which === 9) { // tab\n                if (isListVisible(list)) {\n                    hideList(list, rootElement)(e);\n                }\n            }\n            if (e.which === 38) {\n                return moveSelection(-1, list);\n            }\n            if (e.which === 40) {\n                return isListVisible(list)\n                    ? moveSelection(1, list)\n                    : fetchList(dataSource, userFacingInput, list,\n                        emptyListMessage, rootElement)(e);\n            }\n            if (e.which === 27) {\n                if (!userFacingInput.value) {\n                    hideList(list, rootElement)();\n                    cleanup(valueInput, userFacingInput, rootElement);\n                    userFacingInput.blur();\n                } else {\n                    cleanup(valueInput, userFacingInput, rootElement);\n                    fetchList(dataSource, userFacingInput, list,\n                        emptyListMessage, rootElement)(e);\n                }\n            }\n        }\n        return null;\n    }; };\n\n\n\n/**\n * Handles key up event from the label input\n * @param {DataSource} dataSource\n * @param {HTMLInputElement} valueInput\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLUListElement} list\n * @param {string} emptyListMessage\n * @param {Element} rootElement\n * @return {function}\n */\nvar onKeyUp = function (dataSource, valueInput, userFacingInput, list, emptyListMessage, rootElement) { return function (e) {\n        if (userFacingInput.value) {\n            dirtifyInput(rootElement);\n        } else {\n            cleanup(valueInput, userFacingInput, rootElement);\n        }\n        if (isListVisible(list) && (e.which === 13 || e.which === 9)) {\n            e.stopPropagation();\n            e.preventDefault();\n            selectItem(valueInput, userFacingInput, null, rootElement, list);\n            return false;\n        }\n        if ([38, 40, 27].indexOf(e.which) === -1) {\n            e.stopPropagation();\n            return fetchList(dataSource, userFacingInput, list, emptyListMessage, rootElement)(e);\n        }\n        return null;\n    }; };\n\n\n\n/**\n * Reset the state of the component\n * @param {HTMLInputElement} valueInput\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLElement} root\n */\nvar reset = function (valueInput, userFacingInput, root) {\n    cleanup(valueInput, userFacingInput, root);\n    triggerChangeEvent('change', valueInput);\n    return true;\n};\n\n\n\n/**\n * Returns promised Suggestion by key\n * @param  {DataSource} dataSource\n * @param  {string} keyValue\n * @return {Promise.<Suggestion>}\n */\nvar getInitialValueByKey = function (dataSource, keyValue) { return dataSource.getSuggestionByKey(keyValue); };\n\n\n/**\n * Handles click on the component\n * @param {function} fetchListFn\n * @param {HTMLInputElement} userFacingInput\n * @param {HTMLInputElement} valueInput\n * @param {HTMLUListElement} list\n * @param {HTMLElement} rootElement\n */\n\nvar componentClicked = function (fetchListFn, userFacingInput, valueInput, list, rootElement) { return function (e) {\n    var isInput = closestByClassName('as24-autocomplete__input')(e.target);\n    var isIcon = closestByClassName('as24-autocomplete__icon-wrapper')(e.target);\n    var isList = closestByClassName('as24-autocomplete__list')(e.target);\n    if (userFacingInput.disabled) {\n        return;\n    }\n    if (closestByTag(rootElement)(e.target) === rootElement) {\n        if (isInput) {\n            fetchListFn(e);\n        } else if (isIcon) {\n            if (!userFacingInput.disabled) {\n                if (rootElement.isDirty) {\n                    reset(valueInput, userFacingInput, rootElement);\n                    if (isListVisible(list)) {\n                        fetchListFn(e);\n                        userFacingInput.focus();\n                    }\n                    return;\n                }\n                if (isListVisible(list)) {\n                    hideList(list, rootElement)(e);\n                } else {\n                    userFacingInput.focus();\n                    fetchListFn(e);\n                }\n            }\n        } else if (isList) {\n            var theItem = closestByClassName('as24-autocomplete__list-item')(e.target);\n            if (theItem.dataset.unselectable) {\n                e.stopPropagation();\n                return;\n            }\n            selectItem(valueInput, userFacingInput, theItem, rootElement);\n            rootElement.classList.add('as24-autocomplete--user-input');\n            hideList(list, rootElement)(e);\n        }\n    } else {\n        if (isListVisible(list) && userFacingInput.classList.contains('error')) {\n            valueInput.value = '';\n            triggerChangeEvent('change', valueInput);\n        }\n        hideList(list, rootElement)(e);\n    }\n}; };\n\n\n\n/**\n * When the custom tag has been attached to DOM\n * @this HTMLElement\n */\nfunction elementAttached() {\n    /**\n     * The as24-autocomplete DOM element\n     * @type {HTMLElement}\n     */\n    var root = this;\n\n    /**\n     * The message about no items has been found\n     * @type {string}\n     */\n    var emptyListMessage = root.getAttribute('empty-list-message') || '---';\n\n    /**\n     * The input with which the user can interact\n     * @type {HTMLInputElement}\n     */\n    var userFacingInput = $('[type=text]', root);\n\n    /**\n     * Hidden input in which we actually set the value\n     * @type {HTMLInputElement}\n     */\n    var valueInput = $('[type=hidden]', root);\n\n    /**\n     * The UL-element that represents the suggestion list\n     * @type {HTMLUListElement}\n     */\n    var list = $('.as24-autocomplete__list', root);\n\n    /**\n     * DataSource element\n     * @type {DataSource}\n     */\n    var dataSource = this.querySelector('[role=data-source]');\n\n    if (!dataSource) {\n        throw new Error('The DataSource has not been found');\n    }\n\n    /**\n     * The function that takes an Event and does call to DataSource\n     * @type {Function}\n     */\n    var fetchListFn = fetchList(dataSource, userFacingInput, list, emptyListMessage, root);\n\n    root.isDirty = false;\n\n    setTimeout(function () {\n        if (valueInput.value) {\n            getInitialValueByKey(dataSource, valueInput.value)\n                .then(function (suggestion) {\n                    if (suggestion) {\n                        userFacingInput.value = suggestion.value;\n                        dirtifyInput(root);\n                    }\n                    return true;\n                });\n        }\n    });\n\n    on('click', componentClicked(fetchListFn, userFacingInput, valueInput, list, root), document, true);\n    on('keyup', onKeyUp(dataSource, valueInput, userFacingInput, list, emptyListMessage, root), userFacingInput, true);\n    on('keydown', onKeyDown(dataSource, valueInput, userFacingInput, list, emptyListMessage, root), window, true);\n    on('mouseover', onItemMouseOver(list), list, true);\n}\n\nfunction elementDetached() { }\n\n/**\n * @this {HTMLElement}\n * @param {string} attrName\n * @param {string} oldVal\n * @param {string} newVal\n */\nfunction onAttributeChanged(attrName, oldVal, newVal) {\n    /** @type {HTMLInputElement} */\n    var userFacingInput = $('[type=text]', this);\n\n    /** @type {HTMLUListElement} */\n    var list = $('.as24-autocomplete__list', this);\n\n    if (attrName === 'disabled') {\n        userFacingInput.disabled = newVal === 'true' || newVal === 'disabled';\n        this.classList[userFacingInput.disabled ? 'add' : 'remove']('as24-autocomplete--disabled');\n        hideList(list, this)();\n    }\n}\n\nfunction registerInput() {\n    try {\n        return document.registerElement('as24-autocomplete', {\n            prototype: Object.assign(\n                Object.create(HTMLElement.prototype, {\n                    attachedCallback: { value: elementAttached },\n                    detachedCallback: { value: elementDetached },\n                    attributeChangedCallback: { value: onAttributeChanged }\n                }),\n                /**\n                 * Public API\n                 */\n                {\n                    /**\n                     * Returns the selected value\n                     * @this {HTMLElement}\n                     */\n                    selectedValue: function selectedValue() {\n                        return $('[type=hidden]', this).value;\n                    },\n                    /**\n                     * Returns what user has written\n                     * @this {HTMLElement}\n                     */\n                    userQuery: function userQuery() {\n                        return $('[type=text]', this).value;\n                    },\n                    /**\n                     * returns the bounded data source element\n                     * @this {HTMLElement}\n                     */\n                    dataSourceElement: function dataSourceElement() {\n                        return this.querySelector('[role=data-source]');\n                    },\n                    /**\n                     * Resets the component\n                     * @this {HTMLElement}\n                     */\n                    reset: function reset$1() {\n                        /** @type {HTMLInputElement} */\n                        var userFacingInput = $('[type=text]', this);\n\n                        /** @type {HTMLInputElement} */\n                        var valueInput = $('[type=hidden]', this);\n\n                        return reset(valueInput, userFacingInput, this);\n                    }\n                }\n            )\n        });\n    } catch (e) {\n        if (window && window.console) {\n            window.console.warn('Failed to register CustomElement \"as24-autocomplete\".', e);\n            return null;\n        }\n    }\n    return true;\n}\n\n/**\n * @class\n * @typedef Suggestion\n */\nvar Suggestion = function Suggestion(key, value) {\n    this.key = key;\n    this.value = value;\n};\n\nSuggestion.prototype.toString = function toString () {\n    return (\"Suggestion(\" + (this.key) + \": \" + (this.value) + \")\");\n};\n\n/**\n * Test the string against item's value\\\n * @param {RegExp} regexp\n * @returns {function}\n */\nvar valuePredicate = function (regexp) { return function (item) { return item.value.match(regexp) !== null; }; };\n\n\n/**\n * @class\n * @typedef DataSource\n */\nvar DataSource = (function (HTMLElement) {\n    function DataSource () {\n        HTMLElement.apply(this, arguments);\n    }\n\n    if ( HTMLElement ) DataSource.__proto__ = HTMLElement;\n    DataSource.prototype = Object.create( HTMLElement && HTMLElement.prototype );\n    DataSource.prototype.constructor = DataSource;\n\n    DataSource.prototype.fetchItems = function fetchItems (queryString) {\n        var this$1 = this;\n\n        return new Promise(function (res) {\n            var keyVals = this$1.extractKeyValues();\n            var escapedQueryString = queryString.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n            var startingWith = keyVals\n                .filter(valuePredicate(new RegExp((\"^\" + escapedQueryString), 'ig')));\n            var theRestContaining = keyVals\n                .filter(function (x) { return startingWith.indexOf(x) === -1; })\n                .filter(valuePredicate(new RegExp((\"\" + escapedQueryString), 'ig')));\n            return res(startingWith.concat(theRestContaining));\n        });\n    };\n\n    /**\n     * @param {string} keyValue\n     * @return {Promise.<Suggestion>}\n     */\n    DataSource.prototype.getSuggestionByKey = function getSuggestionByKey (keyValue) {\n        var this$1 = this;\n\n        return new Promise(function (res, rej) {\n            var items = this$1.extractKeyValues();\n            if (keyValue && items) {\n                return res(items.filter(function (item) { return item.key === keyValue; })[0]);\n            }\n            return rej(null);\n        });\n    };\n\n    /**\n     * Extracts a list of objects like { key:string, value:string }\n     * @returns {Array<{key:string, value:string}>}\n     */\n    DataSource.prototype.extractKeyValues = function extractKeyValues () {\n        return Array.prototype.slice.call(this.querySelectorAll('item')).map(function (tag) { return new Suggestion(tag.getAttribute('key'), tag.getAttribute('value')); }\n        );\n    };\n\n    return DataSource;\n}(HTMLElement));\n\nfunction registerDS() {\n    try {\n        return document.registerElement('as24-tags-data-source', DataSource);\n    } catch (e) {\n        return null;\n    }\n}\n\nregisterInput();\nregisterDS();\n"],"file":"as24-autocomplete.js"}